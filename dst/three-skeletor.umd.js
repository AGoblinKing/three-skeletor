!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).skeletor={},t.THREE)}(this,(function(t,e){"use strict";const i=new e.Vector3,o=new e.Vector3,s=new e.Vector3,n=new e.Matrix4;function r(t,e){return e.setFromMatrixPosition(t.matrixWorld)}function h(t,e){e.set(0,0,0);for(let i of t)e.add(i);return e.divideScalar(t.length),e}function l(t,e,r){const a=i,h=o,l=s,c=n,d=n.elements;l.copy(t),a.crossVectors(e,l),0===a.lengthSq()&&(1===Math.abs(e.z)?l.x+=1e-4:l.z+=1e-4,l.normalize(),a.crossVectors(e,l)),a.normalize(),h.crossVectors(l,a),d[0]=a.x,d[4]=h.x,d[8]=l.x,d[1]=a.y,d[5]=h.y,d[9]=l.y,d[2]=a.z,d[6]=h.z,d[10]=l.z,r.setFromRotationMatrix(c)}function c(t,e,i){const o=e.elements,s=t.x*o[0]+t.y*o[4]+t.z*o[8]+o[12],n=t.x*o[1]+t.y*o[5]+t.z*o[9]+o[13],r=t.x*o[2]+t.y*o[6]+t.z*o[10]+o[14],a=t.x*o[3]+t.y*o[7]+t.z*o[11]+o[15];i.set(s/a,n/a,r/a)}const d=new e.Vector3(0,1,0);class _{constructor(t,{constraints:i}={}){this.constraints=i||[],this.bone=t,this.distance=0,this._originalDirection=new e.Vector3,this._originalHinge=new e.Vector3,this._direction=new e.Vector3,this._worldPosition=new e.Vector3,this._isSubBase=!1,this._subBasePositions=null,this.isIKJoint=!0,this._originalUp=new e.Vector3(0,1,0),this._originalUp.applyQuaternion(this.bone.quaternion).normalize(),this._updateWorldPosition()}_setIsSubBase(){this._isSubBase=!0,this._subBasePositions=[]}_applySubBasePositions(){0!==this._subBasePositions.length&&(h(this._subBasePositions,this._worldPosition),this._subBasePositions.length=0)}_applyConstraints(){if(!this.constraints)return;let t=!1;for(let e of this.constraints)if(e&&e._apply){let i=e._apply(this);t=t||i}return t}_setDistance(t){this.distance=t}_getDirection(){return this._direction}_setDirection(t){this._direction.copy(t)}_getDistance(){return this.distance}_updateMatrixWorld(){this.bone.updateMatrixWorld(!0)}_getWorldPosition(){return this._worldPosition}_getWorldDirection(t){return(new e.Vector3).subVectors(this._getWorldPosition(),t._getWorldPosition()).normalize()}_updateWorldPosition(){r(this.bone,this._worldPosition)}_setWorldPosition(t){this._worldPosition.copy(t)}_localToWorldDirection(t){if(this.bone.parent){const e=this.bone.parent.matrixWorld;t.transformDirection(e)}return t}_worldToLocalDirection(t){if(this.bone.parent){const i=(new e.Matrix4).getInverse(this.bone.parent.matrixWorld);t.transformDirection(i)}return t}_applyWorldPosition(){let t=(new e.Vector3).copy(this._direction),i=(new e.Vector3).copy(this._getWorldPosition());if(this.bone.parent){this._updateMatrixWorld(),c(i,(new e.Matrix4).getInverse(this.bone.parent.matrixWorld),i),this.bone.position.copy(i),this._updateMatrixWorld(),this._worldToLocalDirection(t),l(t,d,this.bone.quaternion)}else this.bone.position.copy(i);this.bone.updateMatrix(),this._updateMatrixWorld()}_getWorldDistance(t){return this._worldPosition.distanceTo(t.isIKJoint?t._getWorldPosition():r(t,new e.Vector3))}}class f extends e.Object3D{constructor(t,i,o){if(super(),0!==t){const o=new e.ConeBufferGeometry(i,t,4);o.applyMatrix((new e.Matrix4).makeRotationAxis(new e.Vector3(1,0,0),Math.PI/2)),this.boneMesh=new e.Mesh(o,new e.MeshBasicMaterial({color:16711680,wireframe:!0,depthTest:!1,depthWrite:!1}))}else this.boneMesh=new e.Object3D;this.boneMesh.position.z=t/2,this.add(this.boneMesh),this.axesHelper=new e.AxesHelper(o),this.add(this.axesHelper)}}class u extends e.Object3D{constructor(t,{color:i,showBones:o,boneSize:s,showAxes:n,axesSize:r,wireframe:a}={}){if(super(),s=s||.1,r=r||.2,!t.isIK)throw new Error("IKHelper must receive an IK instance.");this.ik=t,this._meshes=new Map;for(let t of this.ik.chains){const e=[t];for(;e.length;){const i=e.shift();for(let e=0;e<i.joints.length;e++){const o=i.joints[e],n=i.joints[e+1],a=n?n.distance:0;if(i.base===o&&i!==t)continue;const h=new f(a,s,r);h.matrixAutoUpdate=!1,this._meshes.set(o,h),this.add(h)}for(let t of i.chains.values())for(let i of t)e.push(i)}}this.showBones=void 0===o||o,this.showAxes=void 0===n||n,this.wireframe=void 0===a||a,this.color=i||new e.Color(16711799)}get showBones(){return this._showBones}set showBones(t){if(t!==this._showBones){for(let[e,i]of this._meshes)t?i.add(i.boneMesh):i.remove(i.boneMesh);this._showBones=t}}get showAxes(){return this._showAxes}set showAxes(t){if(t!==this._showAxes){for(let[e,i]of this._meshes)t?i.add(i.axesHelper):i.remove(i.axesHelper);this._showAxes=t}}get wireframe(){return this._wireframe}set wireframe(t){if(t!==this._wireframe){for(let[e,i]of this._meshes)i.boneMesh.material&&(i.boneMesh.material.wireframe=t);this._wireframe=t}}get color(){return this._color}set color(t){if(!this._color||!this._color.equals(t)){t=t&&t.isColor?t:new e.Color(t);for(let[e,i]of this._meshes)i.boneMesh.material&&(i.boneMesh.material.color=t);this._color=t}}updateMatrixWorld(t){for(let[t,e]of this._meshes)e.matrix.copy(t.bone.matrixWorld);super.updateMatrixWorld(t)}}const p=new e.Vector3(0,0,-1),w=(new e.Vector3(1,0,0),new e.Vector3),g=new e.Vector3,m=new e.Vector3,x=new e.Vector3,{DEG2RAD:P,RAD2DEG:W}=e.Math;const y=new e.Vector3(0,0,1),{DEG2RAD:D,RAD2DEG:j}=e.Math;t.BoneHelper=f,t.IK=class{constructor(){this.chains=[],this._needsRecalculated=!0,this.isIK=!0,this._orderedChains=null}add(t){if(!t.isIKChain)throw new Error("Argument is not an IKChain.");this.chains.push(t)}recalculate(){this._orderedChains=[];for(let t of this.chains){const e=[];this._orderedChains.push(e);const i=[t];for(;i.length;){const t=i.shift();e.push(t);for(let e of t.chains.values())for(let t of e){if(-1!==i.indexOf(t))throw new Error("Recursive chain structure detected.");i.push(t)}}}}solve(){this._orderedChains||this.recalculate();for(let t of this._orderedChains){let e=1;for(;e>0;){for(let e=t.length-1;e>=0;e--)t[e]._updateJointWorldPositions();for(let e=t.length-1;e>=0;e--)t[e]._forward();let i=!0;for(let e=0;e<t.length;e++){t[e]._backward()>this.tolerance&&(i=!1)}if(i)break;e--}}}getRootBone(){return this.chains[0].base.bone}},t.IKBallConstraint=class{constructor(t){this.angle=t}_apply(t){const i=(new e.Vector3).copy(t._getDirection()),o=t._localToWorldDirection((new e.Vector3).copy(y)).normalize(),s=i.angleTo(o)*j;if(this.angle/2<s){i.normalize();const s=(new e.Vector3).crossVectors(o,i).normalize();return o.applyAxisAngle(s,this.angle*D*.5),t._setDirection(o),!0}return!1}},t.IKChain=class{constructor(){this.isIKChain=!0,this.totalLengths=0,this.base=null,this.effector=null,this.effectorIndex=null,this.chains=new Map,this.origin=null,this.iterations=100,this.tolerance=.01,this._depth=-1,this._targetPosition=new e.Vector3}add(t,{target:i}={}){if(this.effector)throw new Error("Cannot add additional joints to a chain with an end effector.");if(t.isIKJoint||(t=new _(t)),this.joints=this.joints||[],this.joints.push(t),1===this.joints.length)this.base=this.joints[0],this.origin=(new e.Vector3).copy(this.base._getWorldPosition());else{const i=this.joints[this.joints.length-2],o=this.joints[this.joints.length-3];i._updateMatrixWorld(),i._updateWorldPosition(),t._updateWorldPosition();const s=i._getWorldDistance(t);if(0===s)throw new Error("bone with 0 distance between adjacent bone found");t._setDistance(s),t._updateWorldPosition();const n=i._getWorldDirection(t);i._originalDirection=(new e.Vector3).copy(n),t._originalDirection=(new e.Vector3).copy(n),o&&(i._originalHinge=i._worldToLocalDirection(i._originalDirection.clone().cross(o._originalDirection).normalize())),this.totalLengths+=s}return i&&(this.effector=t,this.effectorIndex=t,this.target=i),this}_hasEffector(){return!!this.effector}_getDistanceFromTarget(){return this._hasEffector()?this.effector._getWorldDistance(this.target):-1}connect(t){if(!t.isIKChain)throw new Error("Invalid connection in an IKChain. Must be an IKChain.");if(!t.base.isIKJoint)throw new Error("Connecting chain does not have a base joint.");const e=this.joints.indexOf(t.base);if(this.target&&e===this.joints.length-1)throw new Error("Cannot append a chain to an end joint in a chain with a target.");if(-1===e)throw new Error("Cannot connect chain that does not have a base joint in parent chain.");this.joints[e]._setIsSubBase();let i=this.chains.get(e);return i||(i=[],this.chains.set(e,i)),i.push(t),this}_updateJointWorldPositions(){for(let t of this.joints)t._updateWorldPosition()}_forward(){if(this.origin.copy(this.base._getWorldPosition()),this.target)this._targetPosition.setFromMatrixPosition(this.target.matrixWorld),this.effector._setWorldPosition(this._targetPosition);else if(!this.joints[this.joints.length-1]._isSubBase)return;for(let t=1;t<this.joints.length;t++){const e=this.joints[t];e._isSubBase&&e._applySubBasePositions()}for(let t=this.joints.length-1;t>0;t--){const e=this.joints[t],i=this.joints[t-1],o=i._getWorldDirection(e).multiplyScalar(e.distance).add(e._getWorldPosition());i===this.base&&this.base._isSubBase?this.base._subBasePositions.push(o):i._setWorldPosition(o)}}_backward(){this.base._isSubBase||this.base._setWorldPosition(this.origin);for(let t=0;t<this.joints.length-1;t++){const e=this.joints[t],i=this.joints[t+1],o=e._getWorldPosition(),s=i._getWorldDirection(e);e._setDirection(s),e._applyConstraints(),s.copy(e._direction),this.base===e&&e._isSubBase||e._applyWorldPosition(),i._setWorldPosition(s.multiplyScalar(i.distance).add(o)),t===this.joints.length-2&&(i!==this.effector&&i._setDirection(s),i._applyWorldPosition())}return this._getDistanceFromTarget()}},t.IKHelper=u,t.IKHingeConstraint=class{constructor(t){this.angle=t,this.rotationPlane=new e.Plane}_apply(t){const i=(new e.Vector3).copy(t._getDirection()),o=t._localToWorldDirection(w.copy(p)).normalize(),s=t._localToWorldDirection(g.copy(t._originalHinge)).normalize();this.rotationPlane.normal=s;var n=this.rotationPlane.projectPoint(i,new e.Vector3),r=this.rotationPlane.projectPoint(o,m),a=n.angleTo(r)*W;x.crossVectors(n,r).dot(s)>0&&(a+=180),a>this.angle?(r.applyAxisAngle(s,this.angle/W),t._setDirection(r)):t._setDirection(n)}},t.IKJoint=_,t.getCentroid=h,t.getWorldDistance=function(t,e){return r(t,i),r(e,o),a.distanceTo(b)},t.getWorldPosition=r,t.setQuaternionFromDirection=l,t.transformPoint=c,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=three-skeletor.umd.js.map
