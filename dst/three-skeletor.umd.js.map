{"version":3,"file":"three-skeletor.umd.js","sources":["../src/utils.ts","../src/Joint.ts","../src/IKHelper.ts","../src/IK.ts","../src/HingeConstraint.ts","../src/Chain.ts","../src/BallConstraint.ts"],"sourcesContent":["import { Vector3, Matrix4, Quaternion } from 'three'\r\n\r\n/**\r\n * A collection of utilities.\r\n * @module utils\r\n */\r\n\r\nconst t1 = new Vector3()\r\nconst t2 = new Vector3()\r\nconst t3 = new Vector3()\r\nconst m1 = new Matrix4()\r\n\r\n/**\r\n * Returns the world position of object and sets\r\n * it on target.\r\n *\r\n * @param {THREE.Object3D} object\r\n * @param {THREE.Vector3} target\r\n */\r\nexport function getWorldPosition(object, target) {\r\n\treturn target.setFromMatrixPosition(object.matrixWorld)\r\n}\r\n\r\n/**\r\n * Returns the distance between two objects.\r\n *\r\n * @param {THREE.Object3D} obj1\r\n * @param {THREE.Object3D} obj2\r\n * @return {number}\r\n */\r\nexport function getWorldDistance(obj1, obj2) {\r\n\tgetWorldPosition(obj1, t1)\r\n\tgetWorldPosition(obj2, t2)\r\n\treturn a.distanceTo(b)\r\n}\r\n\r\n/**\r\n * Sets the target to the centroid position between all passed in\r\n * positions.\r\n *\r\n * @param {Array<THREE.Vector3>} positions\r\n * @param {THREE.Vector3} target\r\n */\r\nexport function getCentroid(positions, target) {\r\n\ttarget.set(0, 0, 0)\r\n\tfor (let position of positions) {\r\n\t\ttarget.add(position)\r\n\t}\r\n\ttarget.divideScalar(positions.length)\r\n\r\n\treturn target\r\n}\r\n\r\n/**\r\n * Takes a direction vector and an up vector and sets\r\n * `target` quaternion to the rotation. Similar to THREE.Matrix4's\r\n * `lookAt` function, except rather than taking two Vector3 points,\r\n * we've already calculaeld the direction earlier so skip the first half.\r\n *\r\n * @param {THREE.Vector3} direction\r\n * @param {THREE.Vector3} up\r\n * @param {THREE.Quaternion} target\r\n */\r\nexport function setQuaternionFromDirection(\r\n\tdirection: Vector3,\r\n\tup: Vector3,\r\n\ttarget: Quaternion\r\n) {\r\n\tconst x = t1\r\n\tconst y = t2\r\n\tconst z = t3\r\n\tconst m = m1\r\n\tconst el = m1.elements\r\n\r\n\tz.copy(direction)\r\n\tx.crossVectors(up, z)\r\n\r\n\tif (x.lengthSq() === 0) {\r\n\t\t// parallel\r\n\t\tif (Math.abs(up.z) === 1) {\r\n\t\t\tz.x += 0.0001\r\n\t\t} else {\r\n\t\t\tz.z += 0.0001\r\n\t\t}\r\n\t\tz.normalize()\r\n\t\tx.crossVectors(up, z)\r\n\t}\r\n\r\n\tx.normalize()\r\n\ty.crossVectors(z, x)\r\n\r\n\tel[0] = x.x\r\n\tel[4] = y.x\r\n\tel[8] = z.x\r\n\tel[1] = x.y\r\n\tel[5] = y.y\r\n\tel[9] = z.y\r\n\tel[2] = x.z\r\n\tel[6] = y.z\r\n\tel[10] = z.z\r\n\r\n\ttarget.setFromRotationMatrix(m)\r\n}\r\n\r\n/**\r\n * Implementation of Unity's Transform.transformPoint, which is similar\r\n * to three's Vector3.transformDirection, except we want to take scale into account,\r\n * as we're not transforming a direction. Function taken from BabylonJS.\r\n *\r\n * From BabylonJS's `Vector3.transformCoordinates`:\r\n * Sets the passed vector coordinates with the result of the transformation by the\r\n * passed matrix of the passed vector. This method computes tranformed coordinates only,\r\n * not transformed direction vectors (ie. it takes translation in account)\r\n *\r\n * @see https://docs.unity3d.com/ScriptReference/Transform.TransformPoint.html\r\n * @see https://github.com/BabylonJS/Babylon.js/blob/6050288da37623088d5f613ca2d85aef877c5cd5/src/Math/babylon.math.ts#L1936\r\n * @param {THREE.Vector3} vector\r\n * @param {THREE.Matrix4} matrix\r\n * @param {THREE.Vector3} target\r\n */\r\nexport function transformPoint(\r\n\tvector: Vector3,\r\n\tmatrix: Matrix4,\r\n\ttarget: Vector3\r\n) {\r\n\tconst e = matrix.elements\r\n\r\n\tconst x = vector.x * e[0] + vector.y * e[4] + vector.z * e[8] + e[12]\r\n\tconst y = vector.x * e[1] + vector.y * e[5] + vector.z * e[9] + e[13]\r\n\tconst z = vector.x * e[2] + vector.y * e[6] + vector.z * e[10] + e[14]\r\n\tconst w = vector.x * e[3] + vector.y * e[7] + vector.z * e[11] + e[15]\r\n\ttarget.set(x / w, y / w, z / w)\r\n}\r\n","import { Matrix4, Vector3 } from 'three'\r\nimport {\r\n\ttransformPoint,\r\n\tgetCentroid,\r\n\tgetWorldPosition,\r\n\tsetQuaternionFromDirection,\r\n} from './utils'\r\n\r\nconst Y_AXIS = new Vector3(0, 1, 0)\r\n\r\n/**\r\n * A class for a joint.\r\n */\r\nexport class IKJoint {\r\n\t/**\r\n\t * @param {THREE.Bone} bone\r\n\t * @param {Object} config\r\n\t * @param {Array<IKConstraint>} [config.constraints]\r\n\t */\r\n\tconstructor(bone, { constraints } = {}) {\r\n\t\tthis.constraints = constraints || []\r\n\r\n\t\tthis.bone = bone\r\n\r\n\t\tthis.distance = 0\r\n\r\n\t\tthis._originalDirection = new Vector3()\r\n\t\tthis._originalHinge = new Vector3()\r\n\t\tthis._direction = new Vector3()\r\n\t\tthis._worldPosition = new Vector3()\r\n\t\tthis._isSubBase = false\r\n\t\tthis._subBasePositions = null\r\n\t\tthis.isIKJoint = true\r\n\r\n\t\tthis._originalUp = new Vector3(0, 1, 0)\r\n\t\tthis._originalUp.applyQuaternion(this.bone.quaternion).normalize()\r\n\t\tthis._updateWorldPosition()\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_setIsSubBase() {\r\n\t\tthis._isSubBase = true\r\n\t\tthis._subBasePositions = []\r\n\t}\r\n\r\n\t/**\r\n\t * Consumes the stored sub base positions and apply it as this\r\n\t * joint's world position, clearing the sub base positions.\r\n\t *\r\n\t * @private\r\n\t */\r\n\t_applySubBasePositions() {\r\n\t\tif (this._subBasePositions.length === 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tgetCentroid(this._subBasePositions, this._worldPosition)\r\n\t\tthis._subBasePositions.length = 0\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_applyConstraints() {\r\n\t\tif (!this.constraints) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tlet constraintApplied = false\r\n\t\tfor (let constraint of this.constraints) {\r\n\t\t\tif (constraint && constraint._apply) {\r\n\t\t\t\tlet applied = constraint._apply(this)\r\n\t\t\t\tconstraintApplied = constraintApplied || applied\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn constraintApplied\r\n\t}\r\n\r\n\t/**\r\n\t * Set the distance.\r\n\t * @private\r\n\t * @param {number} distance\r\n\t */\r\n\t_setDistance(distance) {\r\n\t\tthis.distance = distance\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getDirection() {\r\n\t\treturn this._direction\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_setDirection(direction) {\r\n\t\tthis._direction.copy(direction)\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the distance.\r\n\t * @private\r\n\t * @return {THREE.Vector3}\r\n\t */\r\n\t_getDistance() {\r\n\t\treturn this.distance\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_updateMatrixWorld() {\r\n\t\tthis.bone.updateMatrixWorld(true)\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * @return {THREE.Vector3}\r\n\t */\r\n\t_getWorldPosition() {\r\n\t\treturn this._worldPosition\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getWorldDirection(joint) {\r\n\t\treturn new Vector3()\r\n\t\t\t.subVectors(this._getWorldPosition(), joint._getWorldPosition())\r\n\t\t\t.normalize()\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_updateWorldPosition() {\r\n\t\tgetWorldPosition(this.bone, this._worldPosition)\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_setWorldPosition(position) {\r\n\t\tthis._worldPosition.copy(position)\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_localToWorldDirection(direction) {\r\n\t\tif (this.bone.parent) {\r\n\t\t\tconst parent = this.bone.parent.matrixWorld\r\n\t\t\tdirection.transformDirection(parent)\r\n\t\t}\r\n\t\treturn direction\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_worldToLocalDirection(direction) {\r\n\t\tif (this.bone.parent) {\r\n\t\t\tconst inverseParent = new Matrix4().getInverse(\r\n\t\t\t\tthis.bone.parent.matrixWorld\r\n\t\t\t)\r\n\t\t\tdirection.transformDirection(inverseParent)\r\n\t\t}\r\n\t\treturn direction\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_applyWorldPosition() {\r\n\t\tlet direction = new Vector3().copy(this._direction)\r\n\t\tlet position = new Vector3().copy(this._getWorldPosition())\r\n\r\n\t\tconst parent = this.bone.parent\r\n\r\n\t\tif (parent) {\r\n\t\t\tthis._updateMatrixWorld()\r\n\t\t\tlet inverseParent = new Matrix4().getInverse(this.bone.parent.matrixWorld)\r\n\t\t\ttransformPoint(position, inverseParent, position)\r\n\t\t\tthis.bone.position.copy(position)\r\n\r\n\t\t\tthis._updateMatrixWorld()\r\n\r\n\t\t\tthis._worldToLocalDirection(direction)\r\n\t\t\tsetQuaternionFromDirection(direction, Y_AXIS, this.bone.quaternion)\r\n\t\t} else {\r\n\t\t\tthis.bone.position.copy(position)\r\n\t\t}\r\n\r\n\t\t// Update the world matrix so the next joint can properly transform\r\n\t\t// with this world matrix\r\n\t\tthis.bone.updateMatrix()\r\n\t\tthis._updateMatrixWorld()\r\n\t}\r\n\r\n\t/**\r\n\t * @param {IKJoint|THREE.Vector3}\r\n\t * @private\r\n\t * @return {THREE.Vector3}\r\n\t */\r\n\t_getWorldDistance(joint) {\r\n\t\treturn this._worldPosition.distanceTo(\r\n\t\t\tjoint.isIKJoint\r\n\t\t\t\t? joint._getWorldPosition()\r\n\t\t\t\t: getWorldPosition(joint, new Vector3())\r\n\t\t)\r\n\t}\r\n}\r\n","import {\r\n\tObject3D,\r\n\tColor,\r\n\tMatrix4,\r\n\tAxesHelper,\r\n\tMesh,\r\n\tConeBufferGeometry,\r\n\tMeshBasicMaterial,\r\n\tVector3,\r\n} from 'three'\r\n\r\n/**\r\n * Mesh for representing an IKJoint.\r\n * @private\r\n * @extends {THREE.Object3d}\r\n */\r\nexport class BoneHelper extends Object3D {\r\n\t/**\r\n\t * @param {number} height\r\n\t * @param {number?} boneSize\r\n\t * @param {number?} axesSize\r\n\t */\r\n\tconstructor(height, boneSize, axesSize) {\r\n\t\tsuper()\r\n\r\n\t\t// If our bone has 0 height (like an end effector),\r\n\t\t// use a dummy Object3D instead, otherwise the ConeBufferGeometry\r\n\t\t// will fall back to its default and not use 0 height.\r\n\t\tif (height !== 0) {\r\n\t\t\tconst geo = new ConeBufferGeometry(boneSize, height, 4)\r\n\t\t\tgeo.applyMatrix(\r\n\t\t\t\tnew Matrix4().makeRotationAxis(new Vector3(1, 0, 0), Math.PI / 2)\r\n\t\t\t)\r\n\t\t\tthis.boneMesh = new Mesh(\r\n\t\t\t\tgeo,\r\n\t\t\t\tnew MeshBasicMaterial({\r\n\t\t\t\t\tcolor: 0xff0000,\r\n\t\t\t\t\twireframe: true,\r\n\t\t\t\t\tdepthTest: false,\r\n\t\t\t\t\tdepthWrite: false,\r\n\t\t\t\t})\r\n\t\t\t)\r\n\t\t} else {\r\n\t\t\tthis.boneMesh = new Object3D()\r\n\t\t}\r\n\r\n\t\t// Offset the bone so that its rotation point is at the base of the bone\r\n\t\tthis.boneMesh.position.z = height / 2\r\n\t\tthis.add(this.boneMesh)\r\n\r\n\t\tthis.axesHelper = new AxesHelper(axesSize)\r\n\t\tthis.add(this.axesHelper)\r\n\t}\r\n}\r\n\r\n/**\r\n * Class for visualizing an IK system.\r\n * @extends {THREE.Object3d}\r\n */\r\nexport class IKHelper extends Object3D {\r\n\t/**\r\n\t * Creates a visualization for an IK.\r\n\t *\r\n\t * @param {IK} ik\r\n\t * @param {Object} config\r\n\t * @param {THREE.Color} [config.color]\r\n\t * @param {boolean} [config.showBones]\r\n\t * @param {boolean} [config.showAxes]\r\n\t * @param {boolean} [config.wireframe]\r\n\t * @param {number} [config.axesSize]\r\n\t * @param {number} [config.boneSize]\r\n\t */\r\n\tconstructor(\r\n\t\tik,\r\n\t\t{ color, showBones, boneSize, showAxes, axesSize, wireframe } = {}\r\n\t) {\r\n\t\tsuper()\r\n\r\n\t\tboneSize = boneSize || 0.1\r\n\t\taxesSize = axesSize || 0.2\r\n\r\n\t\tif (!ik.isIK) {\r\n\t\t\tthrow new Error('IKHelper must receive an IK instance.')\r\n\t\t}\r\n\r\n\t\tthis.ik = ik\r\n\r\n\t\tthis._meshes = new Map()\r\n\r\n\t\tfor (let rootChain of this.ik.chains) {\r\n\t\t\tconst chainsToMeshify = [rootChain]\r\n\t\t\twhile (chainsToMeshify.length) {\r\n\t\t\t\tconst chain = chainsToMeshify.shift()\r\n\t\t\t\tfor (let i = 0; i < chain.joints.length; i++) {\r\n\t\t\t\t\tconst joint = chain.joints[i]\r\n\t\t\t\t\tconst nextJoint = chain.joints[i + 1]\r\n\t\t\t\t\tconst distance = nextJoint ? nextJoint.distance : 0\r\n\r\n\t\t\t\t\t// If a sub base, don't make another bone\r\n\t\t\t\t\tif (chain.base === joint && chain !== rootChain) {\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst mesh = new BoneHelper(distance, boneSize, axesSize)\r\n\t\t\t\t\tmesh.matrixAutoUpdate = false\r\n\t\t\t\t\tthis._meshes.set(joint, mesh)\r\n\t\t\t\t\tthis.add(mesh)\r\n\t\t\t\t}\r\n\t\t\t\tfor (let subChains of chain.chains.values()) {\r\n\t\t\t\t\tfor (let subChain of subChains) {\r\n\t\t\t\t\t\tchainsToMeshify.push(subChain)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Whether this IKHelper's bones are visible or not.\r\n\t\t *\r\n\t\t * @name IKHelper#showBones\r\n\t\t * @type boolean\r\n\t\t * @default true\r\n\t\t */\r\n\t\tthis.showBones = showBones !== undefined ? showBones : true\r\n\r\n\t\t/**\r\n\t\t * Whether this IKHelper's axes are visible or not.\r\n\t\t *\r\n\t\t * @name IKHelper#showAxes\r\n\t\t * @type boolean\r\n\t\t * @default true\r\n\t\t */\r\n\t\tthis.showAxes = showAxes !== undefined ? showAxes : true\r\n\r\n\t\t/**\r\n\t\t * Whether this IKHelper should be rendered as wireframes or not.\r\n\t\t *\r\n\t\t * @name IKHelper#wireframe\r\n\t\t * @type boolean\r\n\t\t * @default true\r\n\t\t */\r\n\t\tthis.wireframe = wireframe !== undefined ? wireframe : true\r\n\r\n\t\t/**\r\n\t\t * The color of this IKHelper's bones.\r\n\t\t *\r\n\t\t * @name IKHelper#color\r\n\t\t * @type THREE.Color\r\n\t\t * @default new THREE.Color(0xff0077)\r\n\t\t */\r\n\t\tthis.color = color || new Color(0xff0077)\r\n\t}\r\n\r\n\tget showBones() {\r\n\t\treturn this._showBones\r\n\t}\r\n\tset showBones(showBones) {\r\n\t\tif (showBones === this._showBones) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tfor (let [joint, mesh] of this._meshes) {\r\n\t\t\tif (showBones) {\r\n\t\t\t\tmesh.add(mesh.boneMesh)\r\n\t\t\t} else {\r\n\t\t\t\tmesh.remove(mesh.boneMesh)\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._showBones = showBones\r\n\t}\r\n\r\n\tget showAxes() {\r\n\t\treturn this._showAxes\r\n\t}\r\n\tset showAxes(showAxes) {\r\n\t\tif (showAxes === this._showAxes) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tfor (let [joint, mesh] of this._meshes) {\r\n\t\t\tif (showAxes) {\r\n\t\t\t\tmesh.add(mesh.axesHelper)\r\n\t\t\t} else {\r\n\t\t\t\tmesh.remove(mesh.axesHelper)\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._showAxes = showAxes\r\n\t}\r\n\r\n\tget wireframe() {\r\n\t\treturn this._wireframe\r\n\t}\r\n\tset wireframe(wireframe) {\r\n\t\tif (wireframe === this._wireframe) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tfor (let [joint, mesh] of this._meshes) {\r\n\t\t\tif (mesh.boneMesh.material) {\r\n\t\t\t\tmesh.boneMesh.material.wireframe = wireframe\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._wireframe = wireframe\r\n\t}\r\n\r\n\tget color() {\r\n\t\treturn this._color\r\n\t}\r\n\tset color(color) {\r\n\t\tif (this._color && this._color.equals(color)) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tcolor = color && color.isColor ? color : new Color(color)\r\n\t\tfor (let [joint, mesh] of this._meshes) {\r\n\t\t\tif (mesh.boneMesh.material) {\r\n\t\t\t\tmesh.boneMesh.material.color = color\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._color = color\r\n\t}\r\n\r\n\tupdateMatrixWorld(force) {\r\n\t\tfor (let [joint, mesh] of this._meshes) {\r\n\t\t\tmesh.matrix.copy(joint.bone.matrixWorld)\r\n\t\t}\r\n\t\tsuper.updateMatrixWorld(force)\r\n\t}\r\n}\r\n","import { IKChain } from './Chain'\r\n\r\nexport class IK {\r\n\t/**\r\n\t * Create an IK structure.\r\n\t *\r\n\t */\r\n\tconstructor() {\r\n\t\tthis.chains = []\r\n\t\tthis._needsRecalculated = true\r\n\r\n\t\tthis.isIK = true\r\n\r\n\t\t// this.iterations = 1;\r\n\t\t// this.tolerance = 0.05;\r\n\r\n\t\t/**\r\n\t\t * An array of root chains for this IK system, each containing\r\n\t\t * an array of all subchains, including the root chain, for that\r\n\t\t * root chain, in descending-depth order.\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._orderedChains = null\r\n\t}\r\n\r\n\t/**\r\n\t * Adds an IKChain to the IK system.\r\n\t *\r\n\t * @param {IKChain} chain\r\n\t */\r\n\tadd(chain) {\r\n\t\tif (!chain.isIKChain) {\r\n\t\t\tthrow new Error('Argument is not an IKChain.')\r\n\t\t}\r\n\r\n\t\tthis.chains.push(chain)\r\n\t}\r\n\r\n\t/**\r\n\t * Called if there's been any changes to an IK structure.\r\n\t * Called internally. Not sure if this should be supported externally.\r\n\t * @private\r\n\t */\r\n\trecalculate() {\r\n\t\tthis._orderedChains = []\r\n\r\n\t\tfor (let rootChain of this.chains) {\r\n\t\t\tconst orderedChains = []\r\n\t\t\tthis._orderedChains.push(orderedChains)\r\n\r\n\t\t\tconst chainsToSave = [rootChain]\r\n\t\t\twhile (chainsToSave.length) {\r\n\t\t\t\tconst chain = chainsToSave.shift()\r\n\t\t\t\torderedChains.push(chain)\r\n\t\t\t\tfor (let subChains of chain.chains.values()) {\r\n\t\t\t\t\tfor (let subChain of subChains) {\r\n\t\t\t\t\t\tif (chainsToSave.indexOf(subChain) !== -1) {\r\n\t\t\t\t\t\t\tthrow new Error('Recursive chain structure detected.')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tchainsToSave.push(subChain)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Performs the IK solution and updates bones.\r\n\t */\r\n\tsolve() {\r\n\t\t// If we don't have a depth-sorted array of chains, generate it.\r\n\t\t// This is from the first `update()` call after creating.\r\n\t\tif (!this._orderedChains) {\r\n\t\t\tthis.recalculate()\r\n\t\t}\r\n\r\n\t\tfor (let subChains of this._orderedChains) {\r\n\t\t\t// Hardcode to one for now\r\n\t\t\tlet iterations = 1 // this.iterations;\r\n\r\n\t\t\twhile (iterations > 0) {\r\n\t\t\t\tfor (let i = subChains.length - 1; i >= 0; i--) {\r\n\t\t\t\t\tsubChains[i]._updateJointWorldPositions()\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Run the chain's forward step starting with the deepest chains.\r\n\t\t\t\tfor (let i = subChains.length - 1; i >= 0; i--) {\r\n\t\t\t\t\tsubChains[i]._forward()\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Run the chain's backward step starting with the root chain.\r\n\t\t\t\tlet withinTolerance = true\r\n\t\t\t\tfor (let i = 0; i < subChains.length; i++) {\r\n\t\t\t\t\tconst distanceFromTarget = subChains[i]._backward()\r\n\t\t\t\t\tif (distanceFromTarget > this.tolerance) {\r\n\t\t\t\t\t\twithinTolerance = false\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (withinTolerance) {\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\r\n\t\t\t\titerations--\r\n\r\n\t\t\t\t// Get the root chain's base and randomize the rotation, maybe\r\n\t\t\t\t// we'll get a better change at reaching our goal\r\n\t\t\t\t// @TODO\r\n\t\t\t\tif (iterations > 0) {\r\n\t\t\t\t\t// subChains[subChains.length - 1]._randomizeRootRotation();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the root bone of this structure. Currently\r\n\t * only returns the first root chain's bone.\r\n\t *\r\n\t * @return {THREE.Bone}\r\n\t */\r\n\tgetRootBone() {\r\n\t\treturn this.chains[0].base.bone\r\n\t}\r\n}\r\n\r\nexport default IK\r\n","import { Quaternion, Vector3, Plane, Math as ThreeMath } from 'three'\r\n\r\nconst Z_AXIS = new Vector3(0, 0, -1)\r\nconst X_AXIS = new Vector3(1, 0, 0)\r\n\r\nconst t1 = new Vector3()\r\nconst t2 = new Vector3()\r\nconst t3 = new Vector3()\r\nconst t4 = new Vector3()\r\n\r\nconst { DEG2RAD, RAD2DEG } = ThreeMath\r\n\r\n/**\r\n * A class for a constraint.\r\n */\r\nclass IKHingeConstraint {\r\n\t/**\r\n\t * Pass in an angle value in degrees,\r\n\t * Axis of rotation for the constraint is calculated from initial bone positions.\r\n\t *\r\n\t * @param {number} angle\r\n\t */\r\n\tconstructor(angle) {\r\n\t\tthis.angle = angle\r\n\t\tthis.rotationPlane = new Plane()\r\n\t}\r\n\r\n\t/**\r\n\t * Applies a hinge constraint to passed in IKJoint. The direction will always be updated\r\n\t * with this constraint, because it will always be projected onto the rotation plane.\r\n\t * Additionally, an angle constraint will be applied if necessary.\r\n\t *\r\n\t * @param {IKJoint} joint\r\n\t * @private\r\n\t */\r\n\t_apply(joint) {\r\n\t\t// Get direction of joint and parent in world space\r\n\t\tconst direction = new Vector3().copy(joint._getDirection())\r\n\t\tconst parentDirection = joint\r\n\t\t\t._localToWorldDirection(t1.copy(Z_AXIS))\r\n\t\t\t.normalize()\r\n\t\tconst rotationPlaneNormal = joint\r\n\t\t\t._localToWorldDirection(t2.copy(joint._originalHinge))\r\n\t\t\t.normalize()\r\n\t\tthis.rotationPlane.normal = rotationPlaneNormal\r\n\t\tvar projectedDir = this.rotationPlane.projectPoint(direction, new Vector3())\r\n\r\n\t\tvar parentDirectionProjected = this.rotationPlane.projectPoint(\r\n\t\t\tparentDirection,\r\n\t\t\tt3\r\n\t\t)\r\n\t\tvar currentAngle = projectedDir.angleTo(parentDirectionProjected) * RAD2DEG\r\n\r\n\t\t//apply adjustment to angle if it is \"negative\"\r\n\t\tvar cross = t4.crossVectors(projectedDir, parentDirectionProjected)\r\n\t\tif (cross.dot(rotationPlaneNormal) > 0) {\r\n\t\t\tcurrentAngle += 180\r\n\t\t}\r\n\r\n\t\tif (currentAngle > this.angle) {\r\n\t\t\tparentDirectionProjected.applyAxisAngle(\r\n\t\t\t\trotationPlaneNormal,\r\n\t\t\t\tthis.angle / RAD2DEG\r\n\t\t\t)\r\n\t\t\tjoint._setDirection(parentDirectionProjected)\r\n\t\t} else {\r\n\t\t\tjoint._setDirection(projectedDir)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport default IKHingeConstraint\r\n","import { Vector3 } from 'three'\r\nimport { IKJoint } from './Joint'\r\nimport { getCentroid } from './utils'\r\n\r\n/**\r\n * Class representing an IK chain, comprising multiple IKJoints.\r\n */\r\nexport class IKChain {\r\n\t/**\r\n\t * Create an IKChain.\r\n\t */\r\n\tconstructor() {\r\n\t\tthis.isIKChain = true\r\n\t\tthis.totalLengths = 0\r\n\t\tthis.base = null\r\n\t\tthis.effector = null\r\n\t\tthis.effectorIndex = null\r\n\t\tthis.chains = new Map()\r\n\r\n\t\t/* THREE.Vector3 world position of base node */\r\n\t\tthis.origin = null\r\n\r\n\t\tthis.iterations = 100\r\n\t\tthis.tolerance = 0.01\r\n\r\n\t\tthis._depth = -1\r\n\t\tthis._targetPosition = new Vector3()\r\n\t}\r\n\r\n\t/**\r\n\t * Add an IKJoint to the end of this chain.\r\n\t *\r\n\t * @param {IKJoint} joint\r\n\t * @param {Object} config\r\n\t * @param {THREE.Object3D} [config.target]\r\n\t */\r\n\r\n\tadd(joint, { target } = {}) {\r\n\t\tif (this.effector) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'Cannot add additional joints to a chain with an end effector.'\r\n\t\t\t)\r\n\t\t}\r\n\r\n\t\tif (!joint.isIKJoint) {\r\n\t\t\tjoint = new IKJoint(joint)\r\n\t\t}\r\n\r\n\t\tthis.joints = this.joints || []\r\n\t\tthis.joints.push(joint)\r\n\r\n\t\t// If this is the first joint, set as base.\r\n\t\tif (this.joints.length === 1) {\r\n\t\t\tthis.base = this.joints[0]\r\n\t\t\tthis.origin = new Vector3().copy(this.base._getWorldPosition())\r\n\t\t}\r\n\t\t// Otherwise, calculate the distance for the previous joint,\r\n\t\t// and update the total length.\r\n\t\telse {\r\n\t\t\tconst previousJoint = this.joints[this.joints.length - 2]\r\n\t\t\tconst previousPreviousJoint = this.joints[this.joints.length - 3]\r\n\r\n\t\t\tpreviousJoint._updateMatrixWorld()\r\n\t\t\tpreviousJoint._updateWorldPosition()\r\n\t\t\tjoint._updateWorldPosition()\r\n\r\n\t\t\tconst distance = previousJoint._getWorldDistance(joint)\r\n\t\t\tif (distance === 0) {\r\n\t\t\t\tthrow new Error('bone with 0 distance between adjacent bone found')\r\n\t\t\t}\r\n\t\t\tjoint._setDistance(distance)\r\n\r\n\t\t\tjoint._updateWorldPosition()\r\n\t\t\tconst direction = previousJoint._getWorldDirection(joint)\r\n\t\t\tpreviousJoint._originalDirection = new Vector3().copy(direction)\r\n\t\t\tjoint._originalDirection = new Vector3().copy(direction)\r\n\r\n\t\t\tif (previousPreviousJoint) {\r\n\t\t\t\tpreviousJoint._originalHinge = previousJoint._worldToLocalDirection(\r\n\t\t\t\t\tpreviousJoint._originalDirection\r\n\t\t\t\t\t\t.clone()\r\n\t\t\t\t\t\t.cross(previousPreviousJoint._originalDirection)\r\n\t\t\t\t\t\t.normalize()\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t\tthis.totalLengths += distance\r\n\t\t}\r\n\r\n\t\tif (target) {\r\n\t\t\tthis.effector = joint\r\n\t\t\tthis.effectorIndex = joint\r\n\t\t\tthis.target = target\r\n\t\t}\r\n\r\n\t\treturn this\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a boolean indicating whether or not this chain has an end effector.\r\n\t *\r\n\t * @private\r\n\t * @return {boolean}\r\n\t */\r\n\t_hasEffector() {\r\n\t\treturn !!this.effector\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the distance from the end effector to the target. Returns -1 if\r\n\t * this chain does not have an end effector.\r\n\t *\r\n\t * @private\r\n\t * @return {number}\r\n\t */\r\n\t_getDistanceFromTarget() {\r\n\t\treturn this._hasEffector()\r\n\t\t\t? this.effector._getWorldDistance(this.target)\r\n\t\t\t: -1\r\n\t}\r\n\r\n\t/**\r\n\t * Connects another IKChain to this chain. The additional chain's root\r\n\t * joint must be a member of this chain.\r\n\t *\r\n\t * @param {IKChain} chain\r\n\t */\r\n\tconnect(chain) {\r\n\t\tif (!chain.isIKChain) {\r\n\t\t\tthrow new Error('Invalid connection in an IKChain. Must be an IKChain.')\r\n\t\t}\r\n\r\n\t\tif (!chain.base.isIKJoint) {\r\n\t\t\tthrow new Error('Connecting chain does not have a base joint.')\r\n\t\t}\r\n\r\n\t\tconst index = this.joints.indexOf(chain.base)\r\n\r\n\t\t// If we're connecting to the last joint in the chain, ensure we don't\r\n\t\t// already have an effector.\r\n\t\tif (this.target && index === this.joints.length - 1) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'Cannot append a chain to an end joint in a chain with a target.'\r\n\t\t\t)\r\n\t\t}\r\n\r\n\t\tif (index === -1) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'Cannot connect chain that does not have a base joint in parent chain.'\r\n\t\t\t)\r\n\t\t}\r\n\r\n\t\tthis.joints[index]._setIsSubBase()\r\n\r\n\t\tlet chains = this.chains.get(index)\r\n\t\tif (!chains) {\r\n\t\t\tchains = []\r\n\t\t\tthis.chains.set(index, chains)\r\n\t\t}\r\n\t\tchains.push(chain)\r\n\r\n\t\treturn this\r\n\t}\r\n\r\n\t/**\r\n\t * Update joint world positions for this chain.\r\n\t *\r\n\t * @private\r\n\t */\r\n\t_updateJointWorldPositions() {\r\n\t\tfor (let joint of this.joints) {\r\n\t\t\tjoint._updateWorldPosition()\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Runs the forward pass of the FABRIK algorithm.\r\n\t *\r\n\t * @private\r\n\t */\r\n\t_forward() {\r\n\t\t// Copy the origin so the forward step can use before `_backward()`\r\n\t\t// modifies it.\r\n\t\tthis.origin.copy(this.base._getWorldPosition())\r\n\r\n\t\t// Set the effector's position to the target's position.\r\n\r\n\t\tif (this.target) {\r\n\t\t\tthis._targetPosition.setFromMatrixPosition(this.target.matrixWorld)\r\n\t\t\tthis.effector._setWorldPosition(this._targetPosition)\r\n\t\t} else if (!this.joints[this.joints.length - 1]._isSubBase) {\r\n\t\t\t// If this chain doesn't have additional chains or a target,\r\n\t\t\t// not much to do here.\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Apply sub base positions for all joints except the base,\r\n\t\t// as we want to possibly write to the base's sub base positions,\r\n\t\t// not read from it.\r\n\t\tfor (let i = 1; i < this.joints.length; i++) {\r\n\t\t\tconst joint = this.joints[i]\r\n\t\t\tif (joint._isSubBase) {\r\n\t\t\t\tjoint._applySubBasePositions()\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (let i = this.joints.length - 1; i > 0; i--) {\r\n\t\t\tconst joint = this.joints[i]\r\n\t\t\tconst prevJoint = this.joints[i - 1]\r\n\t\t\tconst direction = prevJoint._getWorldDirection(joint)\r\n\r\n\t\t\tconst worldPosition = direction\r\n\t\t\t\t.multiplyScalar(joint.distance)\r\n\t\t\t\t.add(joint._getWorldPosition())\r\n\r\n\t\t\t// If this chain's base is a sub base, set it's position in\r\n\t\t\t// `_subBaseValues` so that the forward step of the parent chain\r\n\t\t\t// can calculate the centroid and clear the values.\r\n\t\t\t// @TODO Could this have an issue if a subchain `x`'s base\r\n\t\t\t// also had its own subchain `y`, rather than subchain `x`'s\r\n\t\t\t// parent also being subchain `y`'s parent?\r\n\t\t\tif (prevJoint === this.base && this.base._isSubBase) {\r\n\t\t\t\tthis.base._subBasePositions.push(worldPosition)\r\n\t\t\t} else {\r\n\t\t\t\tprevJoint._setWorldPosition(worldPosition)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Runs the backward pass of the FABRIK algorithm.\r\n\t *\r\n\t * @private\r\n\t */\r\n\t_backward() {\r\n\t\t// If base joint is a sub base, don't reset it's position back\r\n\t\t// to the origin, but leave it where the parent chain left it.\r\n\t\tif (!this.base._isSubBase) {\r\n\t\t\tthis.base._setWorldPosition(this.origin)\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < this.joints.length - 1; i++) {\r\n\t\t\tconst joint = this.joints[i]\r\n\t\t\tconst nextJoint = this.joints[i + 1]\r\n\t\t\tconst jointWorldPosition = joint._getWorldPosition()\r\n\r\n\t\t\tconst direction = nextJoint._getWorldDirection(joint)\r\n\t\t\tjoint._setDirection(direction)\r\n\r\n\t\t\tjoint._applyConstraints()\r\n\r\n\t\t\tdirection.copy(joint._direction)\r\n\r\n\t\t\t// Now apply the world position to the three.js matrices. We need\r\n\t\t\t// to do this before the next joint iterates so it can generate rotations\r\n\t\t\t// in local space from its parent's matrixWorld.\r\n\t\t\t// If this is a chain sub base, let the parent chain apply the world position\r\n\t\t\tif (!(this.base === joint && joint._isSubBase)) {\r\n\t\t\t\tjoint._applyWorldPosition()\r\n\t\t\t}\r\n\r\n\t\t\tnextJoint._setWorldPosition(\r\n\t\t\t\tdirection.multiplyScalar(nextJoint.distance).add(jointWorldPosition)\r\n\t\t\t)\r\n\r\n\t\t\t// Since we don't iterate over the last joint, handle the applying of\r\n\t\t\t// the world position. If it's also a non-effector, then we must orient\r\n\t\t\t// it to its parent rotation since otherwise it has nowhere to point to.\r\n\t\t\tif (i === this.joints.length - 2) {\r\n\t\t\t\tif (nextJoint !== this.effector) {\r\n\t\t\t\t\tnextJoint._setDirection(direction)\r\n\t\t\t\t}\r\n\t\t\t\tnextJoint._applyWorldPosition()\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this._getDistanceFromTarget()\r\n\t}\r\n}\r\n\r\nexport default IKChain\r\n","import { Vector3, Math as ThreeMath } from 'three'\r\nimport {\r\n\ttransformPoint,\r\n\tgetCentroid,\r\n\tgetWorldPosition,\r\n\tsetQuaternionFromDirection,\r\n} from './utils'\r\n\r\nconst Z_AXIS = new Vector3(0, 0, 1)\r\nconst { DEG2RAD, RAD2DEG } = ThreeMath\r\n\r\n/**\r\n * A class for a constraint.\r\n */\r\nexport class IKBallConstraint {\r\n\tangle: number\r\n\r\n\tconstructor(angle) {\r\n\t\tthis.angle = angle\r\n\t}\r\n\r\n\t/**\r\n\t * Applies a constraint to passed in IKJoint, updating\r\n\t * its direction if necessary. Returns a boolean indicating\r\n\t * if the constraint was applied or not.\r\n\t *\r\n\t * @param {IKJoint} joint\r\n\t * @private\r\n\t * @return {boolean}\r\n\t */\r\n\t_apply(joint) {\r\n\t\t// Get direction of joint and parent in world space\r\n\t\tconst direction = new Vector3().copy(joint._getDirection())\r\n\t\tconst parentDirection = joint\r\n\t\t\t._localToWorldDirection(new Vector3().copy(Z_AXIS))\r\n\t\t\t.normalize()\r\n\r\n\t\t// Find the current angle between them\r\n\t\tconst currentAngle = direction.angleTo(parentDirection) * RAD2DEG\r\n\r\n\t\tif (this.angle / 2 < currentAngle) {\r\n\t\t\tdirection.normalize()\r\n\t\t\t// Find the correction axis and rotate around that point to the\r\n\t\t\t// largest allowed angle\r\n\t\t\tconst correctionAxis = new Vector3()\r\n\t\t\t\t.crossVectors(parentDirection, direction)\r\n\t\t\t\t.normalize()\r\n\r\n\t\t\tparentDirection.applyAxisAngle(correctionAxis, this.angle * DEG2RAD * 0.5)\r\n\t\t\tjoint._setDirection(parentDirection)\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\treturn false\r\n\t}\r\n}\r\n"],"names":[],"mappings":";;;;;;CAEA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;CAEA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;CAEA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;CAEA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;CAEA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;CAEA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;;CC5HA;AACA;CACA;CACA;CACA;;CAEA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;AACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;CC3MA;CACA;CACA;CACA;CACA;;CAEA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;;CAEA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;AACA;CACA;AACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;CC5NA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;AACA;CACA;CAQA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;CC1HA;CACA;AACA;CACA;CACA;CACA;CACA;;CCJA;CACA;CACA;;CAEA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;AACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;AACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;;CC7QA;CACA;AACA;CACA;CACA;CACA;;CAEA;AACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;;;;;;;;;;;;;;;;;;;;;;"}