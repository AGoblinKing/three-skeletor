{"version":3,"file":"three-skeletor.umd.js","sources":["../src/utils.ts","../src/Joint.ts","../src/BallConstraint.ts"],"sourcesContent":["import { Vector3, Matrix4, Quaternion } from 'three'\r\n\r\n/**\r\n * A collection of utilities.\r\n * @module utils\r\n */\r\n\r\nconst t1 = new Vector3()\r\nconst t2 = new Vector3()\r\nconst t3 = new Vector3()\r\nconst m1 = new Matrix4()\r\n\r\n/**\r\n * Returns the world position of object and sets\r\n * it on target.\r\n *\r\n * @param {THREE.Object3D} object\r\n * @param {THREE.Vector3} target\r\n */\r\nexport function getWorldPosition(object, target) {\r\n\treturn target.setFromMatrixPosition(object.matrixWorld)\r\n}\r\n\r\n/**\r\n * Returns the distance between two objects.\r\n *\r\n * @param {THREE.Object3D} obj1\r\n * @param {THREE.Object3D} obj2\r\n * @return {number}\r\n */\r\nexport function getWorldDistance(obj1, obj2) {\r\n\tgetWorldPosition(obj1, t1)\r\n\tgetWorldPosition(obj2, t2)\r\n\treturn a.distanceTo(b)\r\n}\r\n\r\n/**\r\n * Sets the target to the centroid position between all passed in\r\n * positions.\r\n *\r\n * @param {Array<THREE.Vector3>} positions\r\n * @param {THREE.Vector3} target\r\n */\r\nexport function getCentroid(positions, target) {\r\n\ttarget.set(0, 0, 0)\r\n\tfor (let position of positions) {\r\n\t\ttarget.add(position)\r\n\t}\r\n\ttarget.divideScalar(positions.length)\r\n\r\n\treturn target\r\n}\r\n\r\n/**\r\n * Takes a direction vector and an up vector and sets\r\n * `target` quaternion to the rotation. Similar to THREE.Matrix4's\r\n * `lookAt` function, except rather than taking two Vector3 points,\r\n * we've already calculaeld the direction earlier so skip the first half.\r\n *\r\n * @param {THREE.Vector3} direction\r\n * @param {THREE.Vector3} up\r\n * @param {THREE.Quaternion} target\r\n */\r\nexport function setQuaternionFromDirection(\r\n\tdirection: Vector3,\r\n\tup: Vector3,\r\n\ttarget: Quaternion\r\n) {\r\n\tconst x = t1\r\n\tconst y = t2\r\n\tconst z = t3\r\n\tconst m = m1\r\n\tconst el = m1.elements\r\n\r\n\tz.copy(direction)\r\n\tx.crossVectors(up, z)\r\n\r\n\tif (x.lengthSq() === 0) {\r\n\t\t// parallel\r\n\t\tif (Math.abs(up.z) === 1) {\r\n\t\t\tz.x += 0.0001\r\n\t\t} else {\r\n\t\t\tz.z += 0.0001\r\n\t\t}\r\n\t\tz.normalize()\r\n\t\tx.crossVectors(up, z)\r\n\t}\r\n\r\n\tx.normalize()\r\n\ty.crossVectors(z, x)\r\n\r\n\tel[0] = x.x\r\n\tel[4] = y.x\r\n\tel[8] = z.x\r\n\tel[1] = x.y\r\n\tel[5] = y.y\r\n\tel[9] = z.y\r\n\tel[2] = x.z\r\n\tel[6] = y.z\r\n\tel[10] = z.z\r\n\r\n\ttarget.setFromRotationMatrix(m)\r\n}\r\n\r\n/**\r\n * Implementation of Unity's Transform.transformPoint, which is similar\r\n * to three's Vector3.transformDirection, except we want to take scale into account,\r\n * as we're not transforming a direction. Function taken from BabylonJS.\r\n *\r\n * From BabylonJS's `Vector3.transformCoordinates`:\r\n * Sets the passed vector coordinates with the result of the transformation by the\r\n * passed matrix of the passed vector. This method computes tranformed coordinates only,\r\n * not transformed direction vectors (ie. it takes translation in account)\r\n *\r\n * @see https://docs.unity3d.com/ScriptReference/Transform.TransformPoint.html\r\n * @see https://github.com/BabylonJS/Babylon.js/blob/6050288da37623088d5f613ca2d85aef877c5cd5/src/Math/babylon.math.ts#L1936\r\n * @param {THREE.Vector3} vector\r\n * @param {THREE.Matrix4} matrix\r\n * @param {THREE.Vector3} target\r\n */\r\nexport function transformPoint(\r\n\tvector: Vector3,\r\n\tmatrix: Matrix4,\r\n\ttarget: Vector3\r\n) {\r\n\tconst e = matrix.elements\r\n\r\n\tconst x = vector.x * e[0] + vector.y * e[4] + vector.z * e[8] + e[12]\r\n\tconst y = vector.x * e[1] + vector.y * e[5] + vector.z * e[9] + e[13]\r\n\tconst z = vector.x * e[2] + vector.y * e[6] + vector.z * e[10] + e[14]\r\n\tconst w = vector.x * e[3] + vector.y * e[7] + vector.z * e[11] + e[15]\r\n\ttarget.set(x / w, y / w, z / w)\r\n}\r\n","import { Matrix4, Vector3 } from 'three'\r\nimport {\r\n\ttransformPoint,\r\n\tgetCentroid,\r\n\tgetWorldPosition,\r\n\tsetQuaternionFromDirection,\r\n} from './utils'\r\n\r\nconst Y_AXIS = new Vector3(0, 1, 0)\r\n\r\n/**\r\n * A class for a joint.\r\n */\r\nexport class IKJoint {\r\n\t/**\r\n\t * @param {THREE.Bone} bone\r\n\t * @param {Object} config\r\n\t * @param {Array<IKConstraint>} [config.constraints]\r\n\t */\r\n\tconstructor(bone, { constraints } = {}) {\r\n\t\tthis.constraints = constraints || []\r\n\r\n\t\tthis.bone = bone\r\n\r\n\t\tthis.distance = 0\r\n\r\n\t\tthis._originalDirection = new Vector3()\r\n\t\tthis._originalHinge = new Vector3()\r\n\t\tthis._direction = new Vector3()\r\n\t\tthis._worldPosition = new Vector3()\r\n\t\tthis._isSubBase = false\r\n\t\tthis._subBasePositions = null\r\n\t\tthis.isIKJoint = true\r\n\r\n\t\tthis._originalUp = new Vector3(0, 1, 0)\r\n\t\tthis._originalUp.applyQuaternion(this.bone.quaternion).normalize()\r\n\t\tthis._updateWorldPosition()\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_setIsSubBase() {\r\n\t\tthis._isSubBase = true\r\n\t\tthis._subBasePositions = []\r\n\t}\r\n\r\n\t/**\r\n\t * Consumes the stored sub base positions and apply it as this\r\n\t * joint's world position, clearing the sub base positions.\r\n\t *\r\n\t * @private\r\n\t */\r\n\t_applySubBasePositions() {\r\n\t\tif (this._subBasePositions.length === 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tgetCentroid(this._subBasePositions, this._worldPosition)\r\n\t\tthis._subBasePositions.length = 0\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_applyConstraints() {\r\n\t\tif (!this.constraints) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tlet constraintApplied = false\r\n\t\tfor (let constraint of this.constraints) {\r\n\t\t\tif (constraint && constraint._apply) {\r\n\t\t\t\tlet applied = constraint._apply(this)\r\n\t\t\t\tconstraintApplied = constraintApplied || applied\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn constraintApplied\r\n\t}\r\n\r\n\t/**\r\n\t * Set the distance.\r\n\t * @private\r\n\t * @param {number} distance\r\n\t */\r\n\t_setDistance(distance) {\r\n\t\tthis.distance = distance\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getDirection() {\r\n\t\treturn this._direction\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_setDirection(direction) {\r\n\t\tthis._direction.copy(direction)\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the distance.\r\n\t * @private\r\n\t * @return {THREE.Vector3}\r\n\t */\r\n\t_getDistance() {\r\n\t\treturn this.distance\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_updateMatrixWorld() {\r\n\t\tthis.bone.updateMatrixWorld(true)\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * @return {THREE.Vector3}\r\n\t */\r\n\t_getWorldPosition() {\r\n\t\treturn this._worldPosition\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getWorldDirection(joint) {\r\n\t\treturn new Vector3()\r\n\t\t\t.subVectors(this._getWorldPosition(), joint._getWorldPosition())\r\n\t\t\t.normalize()\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_updateWorldPosition() {\r\n\t\tgetWorldPosition(this.bone, this._worldPosition)\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_setWorldPosition(position) {\r\n\t\tthis._worldPosition.copy(position)\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_localToWorldDirection(direction) {\r\n\t\tif (this.bone.parent) {\r\n\t\t\tconst parent = this.bone.parent.matrixWorld\r\n\t\t\tdirection.transformDirection(parent)\r\n\t\t}\r\n\t\treturn direction\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_worldToLocalDirection(direction) {\r\n\t\tif (this.bone.parent) {\r\n\t\t\tconst inverseParent = new Matrix4().getInverse(\r\n\t\t\t\tthis.bone.parent.matrixWorld\r\n\t\t\t)\r\n\t\t\tdirection.transformDirection(inverseParent)\r\n\t\t}\r\n\t\treturn direction\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_applyWorldPosition() {\r\n\t\tlet direction = new Vector3().copy(this._direction)\r\n\t\tlet position = new Vector3().copy(this._getWorldPosition())\r\n\r\n\t\tconst parent = this.bone.parent\r\n\r\n\t\tif (parent) {\r\n\t\t\tthis._updateMatrixWorld()\r\n\t\t\tlet inverseParent = new Matrix4().getInverse(this.bone.parent.matrixWorld)\r\n\t\t\ttransformPoint(position, inverseParent, position)\r\n\t\t\tthis.bone.position.copy(position)\r\n\r\n\t\t\tthis._updateMatrixWorld()\r\n\r\n\t\t\tthis._worldToLocalDirection(direction)\r\n\t\t\tsetQuaternionFromDirection(direction, Y_AXIS, this.bone.quaternion)\r\n\t\t} else {\r\n\t\t\tthis.bone.position.copy(position)\r\n\t\t}\r\n\r\n\t\t// Update the world matrix so the next joint can properly transform\r\n\t\t// with this world matrix\r\n\t\tthis.bone.updateMatrix()\r\n\t\tthis._updateMatrixWorld()\r\n\t}\r\n\r\n\t/**\r\n\t * @param {IKJoint|THREE.Vector3}\r\n\t * @private\r\n\t * @return {THREE.Vector3}\r\n\t */\r\n\t_getWorldDistance(joint) {\r\n\t\treturn this._worldPosition.distanceTo(\r\n\t\t\tjoint.isIKJoint\r\n\t\t\t\t? joint._getWorldPosition()\r\n\t\t\t\t: getWorldPosition(joint, new Vector3())\r\n\t\t)\r\n\t}\r\n}\r\n","import { Vector3, Math as ThreeMath } from 'three'\r\nimport {\r\n\ttransformPoint,\r\n\tgetCentroid,\r\n\tgetWorldPosition,\r\n\tsetQuaternionFromDirection,\r\n} from './utils'\r\n\r\nconst Z_AXIS = new Vector3(0, 0, 1)\r\nconst { DEG2RAD, RAD2DEG } = ThreeMath\r\n\r\n/**\r\n * A class for a constraint.\r\n */\r\nexport class IKBallConstraint {\r\n\tangle: number\r\n\r\n\tconstructor(angle) {\r\n\t\tthis.angle = angle\r\n\t}\r\n\r\n\t/**\r\n\t * Applies a constraint to passed in IKJoint, updating\r\n\t * its direction if necessary. Returns a boolean indicating\r\n\t * if the constraint was applied or not.\r\n\t *\r\n\t * @param {IKJoint} joint\r\n\t * @private\r\n\t * @return {boolean}\r\n\t */\r\n\t_apply(joint) {\r\n\t\t// Get direction of joint and parent in world space\r\n\t\tconst direction = new Vector3().copy(joint._getDirection())\r\n\t\tconst parentDirection = joint\r\n\t\t\t._localToWorldDirection(new Vector3().copy(Z_AXIS))\r\n\t\t\t.normalize()\r\n\r\n\t\t// Find the current angle between them\r\n\t\tconst currentAngle = direction.angleTo(parentDirection) * RAD2DEG\r\n\r\n\t\tif (this.angle / 2 < currentAngle) {\r\n\t\t\tdirection.normalize()\r\n\t\t\t// Find the correction axis and rotate around that point to the\r\n\t\t\t// largest allowed angle\r\n\t\t\tconst correctionAxis = new Vector3()\r\n\t\t\t\t.crossVectors(parentDirection, direction)\r\n\t\t\t\t.normalize()\r\n\r\n\t\t\tparentDirection.applyAxisAngle(correctionAxis, this.angle * DEG2RAD * 0.5)\r\n\t\t\tjoint._setDirection(parentDirection)\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\treturn false\r\n\t}\r\n}\r\n"],"names":[],"mappings":"mRAOA,+tBCCA,giICAA"}